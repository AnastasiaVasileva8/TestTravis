#include "calc.h"
#define LIBAPP_CALC_HPP


/*Задача поиска лексикографически первого пути на графе в глубину. */
#include <iostream>
//#include <stack> // стек
//using namespace std;
//int main()
//{
//	system("chcp 1251");
//	system("cls");
//	
//	int const n = 5;
//	int mas[n][n] = {
//		/*{ 0, 1, 1, 0, 0 },
//		{ 1, 0, 0, 1, 0 },
//		{ 1, 0, 0, 0, 1 },
//		{ 0, 1, 0, 0, 0 },
//		{ 0, 0, 1, 0, 0 }*/
//		{ 0, 1, 1, 1, 0 },
//		{ 1, 0, 1, 1, 0 },
//		{ 1, 1, 0, 1, 1 },
//		{ 1, 1, 1, 0, 1 },
//		{ 0, 0, 1, 1, 0 }
//	};
//	int req;
//	cout << "Начальная вершина = 1" << endl;
//	cout << "Конечная вершина = ";
//	cin >> req;
//	cout << endl;
	//   { 0, 0, 1, 1, 0, 0, 0 }, // матрица смежности
	//{ 1, 0, 0, 0, 0, 0, 0 },
	//{ 1, 0, 0, 0, 1, 0, 0 },
	//{ 1, 0, 0, 0, 1, 0, 0 },
	//{ 0, 0, 0, 1, 0, 1, 1 },
	//{ 0, 0, 1, 0, 1, 0, 0 },
	//{ 0, 0, 0, 0, 1, 0, 0 } };
	//{ 0, 1, 1, 0, 0, 0, 0 }, // матрица смежности
	//{ 1, 0, 1, 0, 0, 0, 0 },
	//{ 1, 1, 0, 1, 1, 0, 0 },
	//{ 0, 0, 1, 0, 1, 0, 0 },
	//{ 0, 0, 1, 1, 0, 1, 1 },
	//{ 0, 0, 0, 0, 1, 0, 0 },
	//{ 1, 0, 0, 0, 1, 0, 0 }
//    mySearch(mas, req);
//	cin.get(); cin.get();
//	return 0;
//}

#include <vector>

void main()
{
	setlocale(LC_ALL, "Rus");
	Spisok A;
	int B, E;
	std::vector<int> myvec = {};
	Lref t; //Рабочий указатель для перемещения 
	// по списку заголовочных звеньев.
	//Построение графа и вывод его структуры .
	myvec =  { 1, 2, 2, 3, 3, 4, 1, 3, 1, 5,6,6, 0 };
	//
	////Построение графа и вывод его структуры Вирта.
	A.MakeGraph(myvec);
	//A.MakeGraph();
	A.PrintGraph(); cout << endl;
	//Определение пути между двумя заданными вершинами графа.
	t = A.GetHead();
	while (t != A.GetTail())
	{
		(*t).Flag = TRUE; t = (*t).Next;
	}
	cout << "Введите начальную вершину пути: "; cin >> B;
	cout << "Введите конечную вершину пути : "; cin >> E;
	cout << "Искомый путь: ";
	A.Path_Depth_First_Search(B, E); cout << endl;
	system("pause");
	//setlocale(LC_ALL, "Russian");
	//Spisok A;
	//char B, E;
	//Lref t; //Рабочий указатель для перемещения  по списку заголовочных звеньев.

	//char x, y;
	/*std::vector<int> myvec = {};*/
	////std::cout << "Вводите начальную вершину дуги: ";
	////std::cin >> x;
	////
	////while (x != 0)
	////{
	//	myvec.push_back(x);
	////	std::cout << "Вводите конечную вершину дуги: ";
	////	std::cin >> y;
	////	//Определим, существует ли в графе дуга (x,y)?
	////
	////	myvec.push_back(y);
	////	std::cout << "Вводите начальную вершину дуги: ";
	////	std::cin >> x;
	////	myvec.push_back(x);
	////}
	//myvec = { 1, 2, 2,2,2, 3, 3, 6, 6, 8, 1, 4, 4, 5, 5, 8, 1, 5, 0 };
	//
	////Построение графа и вывод его структуры Вирта.
	//A.MakeGraph(myvec);
	//A.PrintGraph(); cout << endl;
	////Определение пути между двумя заданными вершинами графа.
	//t = A.GetHead();
	//while (t != A.GetTail())
	//{
	//	(*t).Flag = TRUE; t = (*t).Next;
	//}
	//cout << "Введите начальную вершину пути: "; cin >> B;
	//cout << "Введите конечную вершину пути : "; cin >> E;
	//cout << "Искомый путь: ";
	//A.Go_width(A.GetHead(), B, E);
	//cout << endl;
	//system("pause");
}
